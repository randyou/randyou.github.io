{"meta":{"title":"摸鱼的蜗牛","subtitle":"摸鱼的蜗牛","description":"摸鱼的蜗牛 blog","author":"Randy Ou","url":"http://randyou.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-07-09T07:01:58.506Z","updated":"2020-07-09T07:01:58.506Z","comments":false,"path":"/404.html","permalink":"http://randyou.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-09T07:01:58.506Z","updated":"2020-07-09T07:01:58.506Z","comments":false,"path":"about/index.html","permalink":"http://randyou.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-07-09T07:01:58.506Z","updated":"2020-07-09T07:01:58.506Z","comments":false,"path":"books/index.html","permalink":"http://randyou.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-07-09T07:01:58.506Z","updated":"2020-07-09T07:01:58.506Z","comments":false,"path":"categories/index.html","permalink":"http://randyou.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-07-09T07:01:58.510Z","updated":"2020-07-09T07:01:58.510Z","comments":true,"path":"images/readme.html","permalink":"http://randyou.github.io/images/readme.html","excerpt":"","text":"iamges fold"},{"title":"友情链接","date":"2020-07-09T07:01:58.510Z","updated":"2020-07-09T07:01:58.510Z","comments":true,"path":"links/index.html","permalink":"http://randyou.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-07-09T07:01:58.510Z","updated":"2020-07-09T07:01:58.510Z","comments":false,"path":"repository/index.html","permalink":"http://randyou.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-09T07:01:58.510Z","updated":"2020-07-09T07:01:58.510Z","comments":false,"path":"tags/index.html","permalink":"http://randyou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Gitlab + Jenkins + Harbor + k8s 实现前端持续集成与部署","slug":"gitlab-jenkins-harbor-k8s","date":"2020-07-07T06:20:11.000Z","updated":"2020-07-09T07:01:58.506Z","comments":true,"path":"2020/07/07/gitlab-jenkins-harbor-k8s/","link":"","permalink":"http://randyou.github.io/2020/07/07/gitlab-jenkins-harbor-k8s/","excerpt":"","text":"CI/CD 流程图前提环境已有 Gitlab已有 Jenkins已有 Harbor已有 K8S如果还没有以上的环境，先自行搭建。在 Harbor 中新建一个项目用来管理前端镜像新建 fe 项目进入 fe 项目，新建机器人账号保存令牌信息，将其配置到 Jenkins 中（略）准备一个 Web 项目使用 create-react-app 创建一个 React App，这里就叫 my-app步骤参考 https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#create-react-app123npx create-react-app my-appcd my-appyarn start在项目中新建文件 Nginx.conf，做为 myapp 的 Nginx 配置文件配置文件中将 api 开头的请求都代理到了后端服务，具体地址用 k8s 管理123456789101112131415161718192021222324252627282930# Nginx.confupstream backend &#123; server my-app-backend;&#125;server &#123; server_name _; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; gzip on; gzip_min_length 1k; gzip_comp_level 3; gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript image&#x2F;jpeg image&#x2F;gif image&#x2F;png; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; location &#x2F;api&#x2F; &#123; rewrite ^.+api&#x2F;?(.*)$ &#x2F;$1 break; proxy_pass http:&#x2F;&#x2F;backend; &#125; location &#x2F; &#123; add_header Cache-Control no-cache; try_files $uri $uri &#x2F;index.html; &#125; location &#x2F;static &#123; add_header Cache-Control max-age&#x3D;2592000; &#125;&#125;新建 Dockerfile，用于构建 my-app，生成用于部署的 docker 镜像使用分阶段构建，有效使用缓存1234567891011121314151617# DockerfileFROM node:12.17 AS builderWORKDIR &#x2F;workspaceADD yarn.lock .ADD package.json .RUN yarnADD public publicADD src srcRUN yarn run buildFROM nginx:alpineCOPY Nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;app.confCOPY --from&#x3D;builder &#x2F;workspace&#x2F;build &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;新建 Jenkinsfile，用于执行 Jenkins 流水线10.104.6.214 是 Harbor 服务 IP 地址，10.104.6.215:32567 是 k8s 服务地址，请自行修改为自己的 IP 地址使用 package.json 中的 name 字段作为 k8s 命名空间名和容器名imageName 是镜像的 tag，这里会将镜像上传到 Harbor 的 fe 项目下robot_jenkins-test 是上面创建的 Harbor 机器人账号在 Jenkins 中的配置 ID12345678910111213141516171819202122232425262728293031323334pipeline&#123; agent any environment &#123; branchName &#x3D; sh(returnStdout: true, script: &quot;echo $&#123;GIT_BRANCH&#125; | sed &#39;s&#x2F;origin\\\\&#x2F;&#x2F;&#x2F;g&#39;&quot;).trim() pkgInfo &#x3D; readJSON file: &#39;package.json&#39; pkgName &#x3D; &quot;$&#123;pkgInfo.name&#125;&quot; commitId &#x3D; sh(returnStdout: true, script: &#39;git rev-parse --short HEAD&#39;).trim() imageTag &#x3D; &quot;$&#123;branchName&#125;-$&#123;commitId&#125;&quot; imageName &#x3D; &quot;10.104.6.214&#x2F;fe&#x2F;$&#123;pkgName&#125;:$&#123;imageTag&#125;&quot; &#125; stages&#123; stage(&quot;Build Image&quot;)&#123; steps &#123; retry(3)&#123; script&#123; appImage &#x3D; docker.build(&quot;$&#123;imageName&#125;&quot;) &#125; &#125; &#125; &#125; stage(&quot;Push Image&quot;)&#123; steps &#123; retry(3)&#123; script&#123; docker.withRegistry(&#39;http:&#x2F;&#x2F;10.104.6.214&#x2F;v2&#39;, &#39;robot_jenkins-test&#39;) &#123; appImage.push() appImage.push(&#39;latest&#39;) &#125; &#125; &#125; &#125; &#125; &#125;&#125;将 my-app 提交后推到 Gitlab 上配置 Jenkins登录 Jenkins 服务，新建任务，新建一个流水线配置流水线保存后点击立即构建，测试流水线。流水线将构建出一个镜像并推送到 Harbor。配置 k8s创建 my-app 命名空间用于部署 my-app1kubectl create namespace my-app使用 deployment.yaml 部署 my-app查看 Harbor 的 fe 项目中 my-app 镜像的 tag 为 master-673d6701234567891011121314151617181920212223242526272829# deployment.yamlapiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: my-app # 部署名称 namespace: my-app # 部署到的命名空间 labels: app: my-appspec: replicas: 1 template: metadata: name: my-app labels: app: my-app spec: containers: - name: my-app image: 10.104.6.214&#x2F;fe&#x2F;my-app:master-673d670 imagePullPolicy: IfNotPresent ports: - name: http-port containerPort: 80 imagePullSecrets: - name: harbor-test-fe restartPolicy: Always selector: matchLabels: app: my-app1kubectl apply -f deployment.yamlharbor-test-fe 是拉取镜像所需要的令牌信息，具体配置可参考 k8s 从 Harbor 拉取镜像查看 pod1kubectl get pods -l app&#x3D;my-app -n my-app此时 pod 已经部署成功，但是 Ready 一直是 Fasle，查看容器日志发现以下报错1host not found in upstream &quot;my-app-backend&quot; in &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;app.conf:2是因为没有配置 my-app-backend 的 DNS。配置后端服务地址 my-app-backend这里假设后端服务没有部署在 k8s 集群上，而是部署在 IP 地址为 192.16.100.56 的服务器上，端口为 260031234567891011121314151617181920212223# service.yamlapiVersion: v1kind: Servicemetadata: name: my-app-backend namespace: my-appspec: ports: - protocol: TCP port: 80 targetPort: 26003 ---apiVersion: v1kind: Endpointsmetadata: name: my-app-backendsubsets: - addresses: - ip: 192.16.100.56 ports: - port: 26003部署 service1kubectl apply -f service.yaml删除 pod1kubectl delete pods my-app-ddc88c8f9-xzcl7 -n my-app此时 pod 已经成功运行暴露 Web 服务为 my-app 创建 service1kubectl expose deployment&#x2F;my-app -n my-app配置 ingress 规则my-app.com 是域名，如果没有正式域名，修改本机的 hosts 访问即可12345678910111213141516# ingress.yamlapiVersion: networking.k8s.io&#x2F;v1beta1kind: Ingressmetadata: name: my-app namespace: my-appspec: rules: - host: my-app.com http: paths: - backend: serviceName: my-app servicePort: 80 path: &#x2F; pathType: ImplementationSpecific1kubectl apply -f ingress.yamlJenkins 自动化部署在 kube-system 下创建一个 ServiceAccount123456789101112131415161718192021# serviceAccount.yamlapiVersion: v1kind: ServiceAccountmetadata: name: jenkins-user namespace: kube-system---apiVersion: rbac.authorization.k8s.io&#x2F;v1kind: ClusterRoleBindingmetadata: name: jenkins-user namespace: kube-systemroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: jenkins-user namespace: kube-system1kubectl apply -f serviceAccount.yaml查看刚刚创建的 ServiceAccont 的 token1kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep jenkins-user | awk &#39;&#123;print $1&#125;&#39;)在 Jenkins 增加一个 ID 为 k8s-test-token 的凭据修改 Jeninsfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263pipeline&#123; agent any environment &#123; branchName &#x3D; sh(returnStdout: true, script: &quot;echo $&#123;GIT_BRANCH&#125; | sed &#39;s&#x2F;origin\\\\&#x2F;&#x2F;&#x2F;g&#39;&quot;).trim() pkgInfo &#x3D; readJSON file: &#39;package.json&#39; pkgName &#x3D; &quot;$&#123;pkgInfo.name&#125;&quot; commitId &#x3D; sh(returnStdout: true, script: &#39;git rev-parse --short HEAD&#39;).trim() imageTag &#x3D; &quot;$&#123;branchName&#125;-$&#123;commitId&#125;&quot; imageName &#x3D; &quot;10.104.6.214&#x2F;fe&#x2F;$&#123;pkgName&#125;:$&#123;imageTag&#125;&quot; &#125; stages&#123; stage(&quot;Build Image&quot;)&#123; steps &#123; retry(3)&#123; script&#123; appImage &#x3D; docker.build(&quot;$&#123;imageName&#125;&quot;) &#125; &#125; &#125; &#125; stage(&quot;Push Image&quot;)&#123; steps &#123; retry(3)&#123; script&#123; docker.withRegistry(&#39;http:&#x2F;&#x2F;10.104.6.214&#x2F;v2&#39;, &#39;robot_jenkins-test&#39;) &#123; appImage.push() appImage.push(&#39;latest&#39;) &#125; &#125; &#125; &#125; &#125; stage(&quot;Deploy Test&quot;)&#123; steps&#123; withCredentials([string(credentialsId: &#39;k8s-test-token&#39;, variable: &#39;k8s_test_token&#39;)]) &#123; retry(3)&#123; sh &quot;curl -X PATCH \\ -H \\&quot;content-type: application&#x2F;strategic-merge-patch+json\\&quot; \\ -H \\&quot;Authorization:Bearer $k8s_test_token\\&quot; \\ -d &#39;&#123;\\&quot;spec\\&quot;:&#123;\\&quot;template\\&quot;:&#123;\\&quot;spec\\&quot;:&#123;\\&quot;containers\\&quot;:[&#123;\\&quot;name\\&quot;:\\&quot;$&#123;pkgName&#125;\\&quot;,\\&quot;image\\&quot;:\\&quot;$&#123;imageName&#125;\\&quot;&#125;]&#125;&#125;&#125;&#125;&#39; \\ \\&quot;http:&#x2F;&#x2F;10.104.6.215:32567&#x2F;k8s-api&#x2F;apis&#x2F;apps&#x2F;v1&#x2F;namespaces&#x2F;$&#123;pkgName&#125;&#x2F;deployments&#x2F;$&#123;pkgName&#125;\\&quot;&quot; &#125; &#125; &#125; &#125; stage(&#39;Deploy Production&#39;) &#123; when &#123; environment name: &#39;branchName&#39;, value: &#39;master&#39; &#125; steps &#123; script &#123; timeout(time: 15, unit: &#39;MINUTES&#39;) &#123; input message: &#39;立即部署到生产环境？&#39;, ok: &#39;确认部署生产环境&#39; &#125; retry(3) &#123; echo &#39;Deploying Production&#39; &#125; &#125; &#125; &#125; &#125;&#125;Gitlab 自动触发提交代码到 Gitlab 后将自动触发构建部署","categories":[],"tags":[{"name":"Harbor","slug":"Harbor","permalink":"http://randyou.github.io/tags/Harbor/"},{"name":"Docker","slug":"Docker","permalink":"http://randyou.github.io/tags/Docker/"},{"name":"K8S","slug":"K8S","permalink":"http://randyou.github.io/tags/K8S/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://randyou.github.io/tags/Jenkins/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://randyou.github.io/tags/Gitlab/"}]},{"title":"k8s 从 Harbor 拉取镜像","slug":"k8s-pull-from-harbor","date":"2020-06-16T09:36:10.000Z","updated":"2020-07-09T07:01:58.506Z","comments":true,"path":"2020/06/16/k8s-pull-from-harbor/","link":"","permalink":"http://randyou.github.io/2020/06/16/k8s-pull-from-harbor/","excerpt":"","text":"创建机器人账户，用来给 k8s 从一个私有项目拉取镜像登录 Harbor进入一个私有项目点击机器人账户页签，添加一个机器人账号输入名称如 test，可以勾选永不过期，权限只需要拉取权限就够了，保存保存后生成一个为 robot$test 的机器人账号和对应的令牌，保存成文件待用。创建 imagePullSecrets方式一：使用命令直接创建harbor-registry-key 是要创建的 secrets 的名称，这里叫 harbor-registry-keydocker-server 对应 Harbor 仓库地址docker-username 是上面的 robot$testdocker-password 是 robot$test 对应的令牌 token1kubectl create secret docker-registry harbor-registry-key --docker-server&#x3D;10.104.6.214 --docker-username&#x3D;robot$test --docker-password&#x3D;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE1OTIzMDA1MTQsImlzcyI6ImhhcmJvci10b2tlbi1kZWZhdWx0SXNzdWVyIiwiaWQiOjQsInBpZCI6MiwiYWNjZXNzIjpbeyJSZXNvdXJjZSI6Ii9wcm9qZWN0LzIvcmVwb3NpdG9yeSIsIkFjdGlvbiI6InB1bGwiLCJFZmZlY3QiOiIifV19.sSUxZjxElPHxIlwK7d9yxQ6YpD29mKywXkf5poJeFDdFiDdz3QiNhwlrIcUAX0kt2-j7aeEOnO0mtlmCYRVCgKDQkPLNe3M6O_NN73_HSUWuZyJGGus--nTTe3J2uqFnrN1q9CFtYlhGcuoRPteqoeG4mHwjvnNfpvLAvQZI2Zz2iRG4Nob-5VcBZ0xzyY5oRC3TT0gImLAPQcwZ3ftSccLhXaAJGE2wlrzfWm3UBfAiN_JAhSvlNLX2sg_69YysQmNdwXGYZysTd-xrGl8pihs53CEqQtP_3-KuO1k07qSoG3O85F0qly0CivdIzD2HRJjQ4JrKFY24BiQf7syIvulygYIahYgNY8OF3giCF0q1jY0eg8qFBGAYa4M3KH7aOy_XsJbpHQgLat88lr6se0nWH16OLkRwtHMHvaAjDLm-EWfCMEV7mJgH2lrByqEpuUd5MApMuWoTwR6paNDjlRDunnshYEuy9V3xzcbJwOS4eCGWkGBGyL6vy41Xf87TCDIzKDiH3c4aUueaStlDbRpwPJHHGUpxqontids-YxH5TBf6Bz7mZt9iqdf1aU91bQgwfkmULFo-AqwFF0d5XfsNbAg3-owySgjj3CdT8bkgEj1zh70K8qxjrUMw7gNZLnEyCwVvDEdJKN0b7ZWXnRUezpkQdJs5jLEnifVxF8I方式二：使用 ~/.docker/config.json 创建使用 docker login 登录 Harbor,生成 .docker/config.json12345678[root@test-10-104-6-215 ~]# docker login 10.104.6.214Username: robot$testPassword:WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json.Configure a credential helper to remove this warning. Seehttps:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;login&#x2F;#credentials-storeLogin Succeeded将文件内容转成 base64 输出12[root@test-10-104-6-215 ~]# cat ~&#x2F;.docker&#x2F;config.json |base64 -w 0ewoJImF1dGhzIjogewoJCSIxMC4xMDQuNi4yMTQiOiB7CgkJCSJhdXRoIjogImNtOWliM1FrZEdWemREcGxlVXBvWWtkamFVOXBTbE5WZWtreFRtbEpjMGx1VWpWalEwazJTV3R3V0ZaRFNqa3VaWGxLY0ZsWVVXbFBha1V4VDFSSmVrMUVRVEZOVkZGelNXMXNlbU41U1RaSmJXaG9ZMjFLZG1OcE1UQmlNblJzWW1reGExcFhXbWhrVjNnd1UxaE9lbVJYVm5sSmFYZHBZVmRSYVU5cVVYTkpia0p3V2tOSk5rMXBkMmxaVjA1cVdsaE9la2xxY0dKbGVVcFRXbGhPZG1SWVNtcGFVMGsyU1drNWQyTnRPWEZhVjA0d1RIcEpkbU50Vm5kaU0wNXdaRWM1ZVdWVFNYTkphMFpxWkVkc2RtSnBTVFpKYmtJeFlrZDNhVXhEU2taYWJWcHNXVE5SYVU5cFNXbG1WakU1TG5OVFZYaGFhbmhGYkZCSWVFbHNkMHMzWkRsNWVGRTJXWEJFTWpsdFMzbDNXR3RtTlhCdlNtVkdSR1JHYVVSa2VqTlJhVTVvZDJ4eVNXTlZRVmd3YTNReUxXbzNZV1ZGVDI1UE1HMTBiRzFEV1ZKV1EyZExSRkZyVUV4T1pUTk5OazlmVGs0M00xOUlVMVZYZFZwNVNrZEhkWE10TFc1VVZHVXpTakoxY1VadWNrNHhjVGxEUm5SWmJHaEhZM1Z2VWxCMFpYRnZaVWMwYlVoM2FuWnVUbVp3ZGt4QmRsRmFTVEphZWpKcFVrYzBUbTlpTFRWV1kwSmFNSGg2ZVZrMWIxSkRNMVJVTUdkSmJVeEJVRkZqZDFvelpuUlRZMk5NYUZoaFFVcEhSVEozYkhKNlpsZHRNMVZDWmtGcFRsOUtRV2hUZG14T1RGZ3ljMmRmTmpsWmVYTlJiVTVrZDFoSFdWcDVjMVJrTFhoeVIydzRjR2xvY3pVelEwVnhVWFJRWHpNdFMzVlBNV3N3TjNGVGIwY3pUemcxUmpCeGJIa3dRMmwyWkVsNlJESklVa3BxVVRSS2NrdEdXVEkwUW1sUlpqZHplVWwyZFd4NVoxbEpZV2haWjA1Wk9FOUdNMmRwUTBZd2NURnFXVEJsWnpoeFJrSkhRVmxoTkUwelMwZzNZVTk1WDFoelNtSndTRkZuVEdGME9EaHNjalp6WlRCdVYwZ3hOazlNYTFKM2RFaE5TSFpoUVdwRVRHMHRSVmRtUTAxRlZqZHRTbWRJTW14eVFubHhSWEIxVldRMVRVRndUWFZYYjFSM1VqWndZVTVFYW14U1JIVnVibk5vV1VWMWVUbFdNM2g2WTJKS2QwOVROR1ZEUjFkclIwSkhlVXcyZG5rME1WaG1PRGRVUTBSSmVrdEVhVWd6WXpSaFZYVmxZVk4wYkVSaVVuQjNVRXBJU0VkVmNIaHhiMjUwYVdSekxWbDRTRFZVUW1ZMlFubzNiVnAwT1dseFpHWXhZVlU1TVdKUlozZG1hMjFWVEVadkxVRnhkMFpHTUdRMVdHWnpUbUpCWnpNdGIzZDVVMmRxYWpORFpGUTRZbXRuUldveGVtZzNNRXM0Y1hocWNsVk5kemRuVGxwTWJrVjVRM2RXZGtSRlpFcExUakJpTjFwWFdHNVNWV1Y2Y0d0UlpFcHpOV3BNUlc1cFpsWjRSamhKIgoJCX0KCX0sCgkiSHR0cEhlYWRlcnMiOiB7CgkJIlVzZXItQWdlbnQiOiAiRG9ja2VyLUNsaWVudC8xOS4wMy44IChsaW51eCkiCgl9Cn0&#x3D;创建 secret.yaml 文件，内容如下，.dockerconfigjson 的值为上面输出的内容1234567apiVersion: v1kind: Secretmetadata: name: harbor-registry-keytype: kubernetes.io&#x2F;dockerconfigjsondata: .dockerconfigjson: ewoJImF1dGhzIjogewoJCSIxMC4xMDQuNi4yMTQiOiB7CgkJCSJhdXRoIjogImNtOWliM1FrZEdWemREcGxlVXBvWWtkamFVOXBTbE5WZWtreFRtbEpjMGx1VWpWalEwazJTV3R3V0ZaRFNqa3VaWGxLY0ZsWVVXbFBha1V4VDFSSmVrMUVRVEZOVkZGelNXMXNlbU41U1RaSmJXaG9ZMjFLZG1OcE1UQmlNblJzWW1reGExcFhXbWhrVjNnd1UxaE9lbVJYVm5sSmFYZHBZVmRSYVU5cVVYTkpia0p3V2tOSk5rMXBkMmxaVjA1cVdsaE9la2xxY0dKbGVVcFRXbGhPZG1SWVNtcGFVMGsyU1drNWQyTnRPWEZhVjA0d1RIcEpkbU50Vm5kaU0wNXdaRWM1ZVdWVFNYTkphMFpxWkVkc2RtSnBTVFpKYmtJeFlrZDNhVXhEU2taYWJWcHNXVE5SYVU5cFNXbG1WakU1TG5OVFZYaGFhbmhGYkZCSWVFbHNkMHMzWkRsNWVGRTJXWEJFTWpsdFMzbDNXR3RtTlhCdlNtVkdSR1JHYVVSa2VqTlJhVTVvZDJ4eVNXTlZRVmd3YTNReUxXbzNZV1ZGVDI1UE1HMTBiRzFEV1ZKV1EyZExSRkZyVUV4T1pUTk5OazlmVGs0M00xOUlVMVZYZFZwNVNrZEhkWE10TFc1VVZHVXpTakoxY1VadWNrNHhjVGxEUm5SWmJHaEhZM1Z2VWxCMFpYRnZaVWMwYlVoM2FuWnVUbVp3ZGt4QmRsRmFTVEphZWpKcFVrYzBUbTlpTFRWV1kwSmFNSGg2ZVZrMWIxSkRNMVJVTUdkSmJVeEJVRkZqZDFvelpuUlRZMk5NYUZoaFFVcEhSVEozYkhKNlpsZHRNMVZDWmtGcFRsOUtRV2hUZG14T1RGZ3ljMmRmTmpsWmVYTlJiVTVrZDFoSFdWcDVjMVJrTFhoeVIydzRjR2xvY3pVelEwVnhVWFJRWHpNdFMzVlBNV3N3TjNGVGIwY3pUemcxUmpCeGJIa3dRMmwyWkVsNlJESklVa3BxVVRSS2NrdEdXVEkwUW1sUlpqZHplVWwyZFd4NVoxbEpZV2haWjA1Wk9FOUdNMmRwUTBZd2NURnFXVEJsWnpoeFJrSkhRVmxoTkUwelMwZzNZVTk1WDFoelNtSndTRkZuVEdGME9EaHNjalp6WlRCdVYwZ3hOazlNYTFKM2RFaE5TSFpoUVdwRVRHMHRSVmRtUTAxRlZqZHRTbWRJTW14eVFubHhSWEIxVldRMVRVRndUWFZYYjFSM1VqWndZVTVFYW14U1JIVnVibk5vV1VWMWVUbFdNM2g2WTJKS2QwOVROR1ZEUjFkclIwSkhlVXcyZG5rME1WaG1PRGRVUTBSSmVrdEVhVWd6WXpSaFZYVmxZVk4wYkVSaVVuQjNVRXBJU0VkVmNIaHhiMjUwYVdSekxWbDRTRFZVUW1ZMlFubzNiVnAwT1dseFpHWXhZVlU1TVdKUlozZG1hMjFWVEVadkxVRnhkMFpHTUdRMVdHWnpUbUpCWnpNdGIzZDVVMmRxYWpORFpGUTRZbXRuUldveGVtZzNNRXM0Y1hocWNsVk5kemRuVGxwTWJrVjVRM2RXZGtSRlpFcExUakJpTjFwWFdHNVNWV1Y2Y0d0UlpFcHpOV3BNUlc1cFpsWjRSamhKIgoJCX0KCX0sCgkiSHR0cEhlYWRlcnMiOiB7CgkJIlVzZXItQWdlbnQiOiAiRG9ja2VyLUNsaWVudC8xOS4wMy44IChsaW51eCkiCgl9Cn0&#x3D;创建 Secrets1kubectl create -f secret.yaml使用 Secrets创建 deployment.yaml，内容如下12345678910111213141516171819202122apiVersion: apps&#x2F;v1kind: Deploymentmetadata: name: nginx-appspec: replicas: 1 selector: matchLabels: app: nginx-app template: metadata: labels: app: nginx-app spec: containers: - name: nginx-app image: 10.104.6.214&#x2F;nginx:alpine # 使用 Harbor 上的镜像 imagePullPolicy: Always ports: - containerPort: 80 imagePullSecrets: - name: harbor-registry-key # 使用刚刚创建的 Harbor Secrets执行部署1kubectl create -f deployment.yaml如果没有成功，检查 deployment 与 创建 Secrets 的 namespace 是否相同","categories":[],"tags":[{"name":"Harbor","slug":"Harbor","permalink":"http://randyou.github.io/tags/Harbor/"},{"name":"k8s","slug":"k8s","permalink":"http://randyou.github.io/tags/k8s/"}]},{"title":"docker login 登录 Harbor","slug":"docker-login-harbor","date":"2020-06-16T07:00:20.000Z","updated":"2020-07-09T07:01:58.506Z","comments":true,"path":"2020/06/16/docker-login-harbor/","link":"","permalink":"http://randyou.github.io/2020/06/16/docker-login-harbor/","excerpt":"","text":"安装好 Harbor 后如果没有启用 https 直接登录会报错1234[root@test-10-104-6-213 ~]# docker login 10.104.6.214Username: adminPassword:Error response from daemon: Get https:&#x2F;&#x2F;10.104.6.214&#x2F;v2&#x2F;: dial tcp 10.104.6.214:443: connect: connection refused修改 daemon.json（如果没有就新建一个）1vim &#x2F;etc&#x2F;docker&#x2F;daemon.json增加或修改内容如下123&#123; &quot;insecure-registries&quot;:[&quot;10.104.6.214&quot;]&#125;重启 docker 服务1systemctl restart docker重新尝试登录1234[root@test-10-104-6-213 ~]# docker login 10.104.6.214Username: adminPassword:Error response from daemon: Get http:&#x2F;&#x2F;10.104.6.214&#x2F;v2&#x2F;: Get http:&#x2F;&#x2F;harbor-test-reg.mydomain.com&#x2F;service&#x2F;token?account&#x3D;admin&amp;client_id&#x3D;docker&amp;offline_token&#x3D;true&amp;service&#x3D;harbor-registry: dial tcp: lookup harbor-test-reg.mydomain.com on 172.16.30.212:53: no such host如果出现类似错误是应为没有找到 harbor-test-reg.mydomain.com 这个域名。我这里并不存在这个域名，所以修改 /etc/hosts，增加一个条目110.104.6.214 harbor-test-reg.mydomain.com再次尝试登录12345678[root@test-10-104-6-213 ~]# docker login 10.104.6.214Username: adminPassword:WARNING! Your password will be stored unencrypted in &#x2F;root&#x2F;.docker&#x2F;config.json.Configure a credential helper to remove this warning. Seehttps:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline&#x2F;login&#x2F;#credentials-storeLogin Succeeded登录成功推送本地镜像到 Habor登录成功后就可以推送镜像啦1234# 给本地 node:12.17 打一个 tagdocker tag node:12.17 10.104.6.214&#x2F;node:12.17# 推送到 Harbordocker push 10.104.6.214&#x2F;node:12.17","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://randyou.github.io/tags/docker/"},{"name":"Harbor","slug":"Harbor","permalink":"http://randyou.github.io/tags/Harbor/"}]},{"title":"CentOS 7.3 安装 Harbor 镜像仓库","slug":"harbor-install","date":"2020-06-16T06:13:23.000Z","updated":"2020-07-09T07:01:58.506Z","comments":true,"path":"2020/06/16/harbor-install/","link":"","permalink":"http://randyou.github.io/2020/06/16/harbor-install/","excerpt":"","text":"准备阶段开启 80、443、4443 端口当然你也可以选择关掉防火墙12345firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanentfirewall-cmd --zone&#x3D;public --add-port&#x3D;443&#x2F;tcp --permanentfirewall-cmd --zone&#x3D;public --add-port&#x3D;4443&#x2F;tcp --permanentfirewall-cmd --reload安装 Docker123456789101112# step 1: 安装必要的一些系统工具sudo yum install -y yum-utils device-mapper-persistent-data lvm2# Step 2: 添加软件源信息sudo yum-config-manager --add-repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo# Step 3: 更新并安装Docker-CEsudo yum makecache fastsudo yum -y install docker-ce# Step 4: 开启Docker服务sudo systemctl enable docker --now安装 docker-compose12345sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.26.0&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-composesudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose安装最新 openssl1yum install openssl -y下载离线 Harbor v2.0.0 安装包与校验文件123wget https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases&#x2F;download&#x2F;v2.0.0&#x2F;harbor-offline-installer-v2.0.0.tgzwget https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases&#x2F;download&#x2F;v2.0.0&#x2F;harbor-offline-installer-v2.0.0.tgz.asc校验下载的安装包检验 MD5123wget https:&#x2F;&#x2F;github.com&#x2F;goharbor&#x2F;harbor&#x2F;releases&#x2F;download&#x2F;v2.0.0&#x2F;md5summd5sum -c md5sum如果校验成功会显示如下信息1234567md5sum: harbor-online-installer-v2.0.0.tgz: No such file or directoryharbor-online-installer-v2.0.0.tgz: FAILED open or readmd5sum: harbor-online-installer-v2.0.0.tgz.asc: No such file or directoryharbor-online-installer-v2.0.0.tgz.asc: FAILED open or readharbor-offline-installer-v2.0.0.tgz: OKharbor-offline-installer-v2.0.0.tgz.asc: OKmd5sum: WARNING: 2 listed files could not be read上面的信息包含刚刚下载的离线安装包提示 OK12harbor-offline-installer-v2.0.0.tgz: OKharbor-offline-installer-v2.0.0.tgz.asc: OK校验 GnuPG 签名获取签名公钥1gpg --keyserver hkps:&#x2F;&#x2F;keyserver.ubuntu.com --recv-keys 644FF454C0B4115C获取成功后信息如下12345gpg: requesting key C0B4115C from hkps server keyserver.ubuntu.comgpg: &#x2F;root&#x2F;.gnupg&#x2F;trustdb.gpg: trustdb createdgpg: key C0B4115C: public key &quot;Harbor-sign (The key for signing Harbor build) &lt;jiangd@vmware.com&gt;&quot; importedgpg: Total number processed: 1gpg: imported: 1 (RSA: 1)验证文件1gpg -v --keyserver hkps:&#x2F;&#x2F;keyserver.ubuntu.com --verify harbor-offline-installer-v2.0.0.tgz.asc成功看到签名信息如下12345678910Version: GnuPG v1gpg: armor header:gpg: assuming signed data in &#96;harbor-offline-installer-v2.0.0.tgz&#39;gpg: Signature made Mon 11 May 2020 06:49:33 PM CST using RSA key ID C0B4115Cgpg: using PGP trust modelgpg: Good signature from &quot;Harbor-sign (The key for signing Harbor build) &lt;jiangd@vmware.com&gt;&quot;gpg: WARNING: This key is not certified with a trusted signature!gpg: There is no indication that the signature belongs to the owner.Primary key fingerprint: 7722 D168 DAEC 4578 06C9 6FF9 644F F454 C0B4 115Cgpg: binary signature, digest algorithm SHA1安装准备把解压出来的 harbor 文件夹放到你想安装的地方，比如 /usr/local/harbor1234567# step 1: 解压离线安装包tar xvf harbor-offline-installer-v2.0.0.tgz# step 2: 编辑配置文件cd harborcp harbor.yml.tmpl harbor.ymlvim harbor.yml需要修改以下内容hostname：修改成需要使用的域名，为了能外部访问，不要使用 127.0.0.1 或 localhost1hostname: reg.mydomain.comhttps 配置如果没有可以先注释掉1234567# https related confighttps: # https port for harbor, default is 443 port: 443 # The path of cert and key files for nginx certificate: &#x2F;your&#x2F;certificate&#x2F;path private_key: &#x2F;your&#x2F;private&#x2F;key&#x2F;pathdata_volume：文件存储地址1data_volume: &#x2F;data开始安装执行以下命令开始安装1bash install.sh最后看到1Harbor has been installed and started successfully.就是安装成功了访问 Harbor访问之前配置的域名 reg.mydomain.com 或使用 ip 地址访问就可以进入页面使用用户名 admin 与 之前配置文件中的密码登录，没有修改密码的话默认 Harbor12345","categories":[],"tags":[{"name":"Harbor","slug":"Harbor","permalink":"http://randyou.github.io/tags/Harbor/"},{"name":"Docker","slug":"Docker","permalink":"http://randyou.github.io/tags/Docker/"}]},{"title":"Dockerfile 备忘","slug":"dockerfile-memo","date":"2020-06-13T13:29:23.000Z","updated":"2020-07-09T07:01:58.506Z","comments":true,"path":"2020/06/13/dockerfile-memo/","link":"","permalink":"http://randyou.github.io/2020/06/13/dockerfile-memo/","excerpt":"","text":"使用多阶段构建多阶段构建有效使用镜像层级缓存，加快构建速度优先添加变化频率更低的文件，提升缓存命中率最终镜像中不包含构建阶段使用的工具，大量减小镜像体积使用更小的基础镜像更小的基础镜像有效节省大量磁盘空间，提高传输效率使用 alpine 文件系统通常能获得更小的镜像example12345678910111213FROM node:alpine AS builderWORKDIR &#x2F;workspace # 指定工作目录COPY yarn.lock . COPY package.json . # 拷贝安装依赖使用到的项目文件 yarn.lock 与 package.json 到当前目录RUN yarn # 安装依赖，yarn.lock 与 package.json 内容不改变的情况下第二次及之后的构建可以命中缓存COPY public publicCOPY src src # 拷贝打包阶段用到的源码文件等，排除其他打包阶段不需要的文件可以更有效率使用缓存RUN yarn run build # 打包FROM nginx:alpine # 从另一个基础镜像开始构建最终的镜像COPY nginx.conf.template &#x2F;etc&#x2F;nginx&#x2F;templates&#x2F;app.conf.template # 拷贝 nginx 配置模版COPY --from&#x3D;builder &#x2F;workspace&#x2F;build &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html # 从上个阶段的镜像 builder 中拷贝打包好的静态资源到 nginx 默认静态文件目录","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://randyou.github.io/tags/docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://randyou.github.io/tags/Dockerfile/"}]}],"categories":[],"tags":[{"name":"Harbor","slug":"Harbor","permalink":"http://randyou.github.io/tags/Harbor/"},{"name":"Docker","slug":"Docker","permalink":"http://randyou.github.io/tags/Docker/"},{"name":"K8S","slug":"K8S","permalink":"http://randyou.github.io/tags/K8S/"},{"name":"Jenkins","slug":"Jenkins","permalink":"http://randyou.github.io/tags/Jenkins/"},{"name":"Gitlab","slug":"Gitlab","permalink":"http://randyou.github.io/tags/Gitlab/"},{"name":"k8s","slug":"k8s","permalink":"http://randyou.github.io/tags/k8s/"},{"name":"docker","slug":"docker","permalink":"http://randyou.github.io/tags/docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"http://randyou.github.io/tags/Dockerfile/"}]}